<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ngtmuzi的博客</title>
    <link>https://ngtmuzi.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>现役码农，node.js后端</description>
    <pubDate>Sun, 03 Mar 2024 07:26:41 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>2020年终小结</title>
      <link>https://ngtmuzi.github.io/2020%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93/</link>
      <guid>https://ngtmuzi.github.io/2020%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93/</guid>
      <pubDate>Sat, 23 Jan 2021 02:30:47 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;我一直以来想要保持每月一更新博客的进度，但出于工作上的繁杂事务过多且确实没有积累什么干货，因此还是隔了很久；尤其是我发现只有在投简历时博客访问量才有所上升这一点——我一开始写博客实际上就是为了让自己的技术历程更充实能更容易找工作，但这种功利的想法反而会让我提不起写博客的劲。
        
      
      </description>
      
      <content:encoded><![CDATA[<p>我一直以来想要保持每月一更新博客的进度，但出于工作上的繁杂事务过多且确实没有积累什么干货，因此还是隔了很久；尤其是我发现只有在投简历时博客访问量才有所上升这一点——我一开始写博客实际上就是为了让自己的技术历程更充实能更容易找工作，但这种功利的想法反而会让我提不起写博客的劲。</p><p>因为没写 19 年的总结，这里稍微记录一些吧：</p><p>19 年 12 月去了一次武汉，当时有关不明肺炎的报道已经持续几天了，我到了之后就在楼下便利店买了口罩，免于一劫，我也没想到乘坐飞机离开时回头看的那个黑霾笼罩的城市会在几个月后经历如此多变故。</p><p>然后我辞职了，离开了一直任职近 5 年的公司。</p><p>20 年 3 月份入职了新公司，不过直到现在都是在接手各个旧项目，语言还各有不同，这让我兴起了继续找工作的念头。有一次好像是到了总监轮面试，听闻我上一次的离职原因是对老板不满后直接中断了面试，我后来想了几次，毕竟我不是走到那个位置的人，还是不会考虑这么忠诚、职场素养、价值观之类的东西。也有几次碰到的面试官让我造火箭，那抱歉确实造不出来，希望你工作中真的是想要造火箭。有的时候又在想，现在的组长是怎么看待我的，我现在的表现跟面试时的形象应该差挺多的。多次尝试无果后，还是安定下来，把 2020 过完了。</p><p>几乎戴着口罩写了一年的代码，说收获的话并没有太多，只是 typescript 和 dockerfile 写得更熟了，可能也跟我懈怠的性格有关，光想呆在舒适区里。脑子里混混乱乱想了一些东西，结合几次面试失败的经历，也考虑是不是程序员的生涯要到头了，但后面又被蛊惑买了个年金保险，不得已还是要工作赚钱，不然保险金都付不起了。</p><p>生活方面，因为自己一个人住了所以想养只狗，柴犬，但又想着逢年过节的时候不好处理，暂时没实现。元旦去找同学玩了一趟，最终好像不怎么开心；找了高三一起打过工，现在在附近上班的前同事想约喝茶，但好像并不乐意。</p><p>娱乐方面，今年着实看了不少电影、剧集和动画，主要是找那些大名鼎鼎但还没看过的电影。误打误撞地看了《守望者》和《LOGAN》这两个反英雄类型片，值得推荐，还有今年的《心灵奇旅》。日剧也补了《医龙》系列、《HERO》系列和不得不看的《半泽直树》第二季。医龙中的神医主角的演员——坂口宪二好像是罹患重病没有办法继续出演了，令人感叹比戏剧更戏剧的是现实。动画看的着实不多，推荐《排球少年》。</p><p>我可能后面会在博客更新更多私人相关的内容而非技术类文章（也有可能在别的平台，随便了），毕竟程序员生涯应该也只是人生中的一小段时间。</p><p>21 年的希望的话，感觉能多接触一些新的领域，找到一些新的乐趣吧，不指望世界和平。</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/2020%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>维持一个超长时间的mongodb游标</title>
      <link>https://ngtmuzi.github.io/%E7%BB%B4%E6%8C%81%E4%B8%80%E4%B8%AA%E8%B6%85%E9%95%BF%E6%97%B6%E9%97%B4%E7%9A%84mongodb%E6%B8%B8%E6%A0%87/</link>
      <guid>https://ngtmuzi.github.io/%E7%BB%B4%E6%8C%81%E4%B8%80%E4%B8%AA%E8%B6%85%E9%95%BF%E6%97%B6%E9%97%B4%E7%9A%84mongodb%E6%B8%B8%E6%A0%87/</guid>
      <pubDate>Wed, 17 Jun 2020 10:29:46 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;本文使用的是node.js版本的mongodb连接库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写这篇的时候才发现我根本没写过&lt;code&gt;tag&lt;/code&gt;是 &lt;a href=&quot;https://ngtmuzi.com/tags/mongodb/&quot;&gt;#mongodb&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>本文使用的是node.js版本的mongodb连接库</strong></p><p>写这篇的时候才发现我根本没写过<code>tag</code>是 <a href="https://ngtmuzi.com/tags/mongodb/">#mongodb</a> 的博客，足以见得知识浅薄，甚至这篇也没有什么技术含量</p><p>有个有趣的工作是遍历某mongo库的索引，对其上符合要求的文档做某些操作，数据量大到可能要跑十天半个月，中途可能还要避开业务高峰期，而每次都用<code>find(&#123;_id:&#123;$gt:lastid&#125;&#125;).sort().skip().limit()</code>感觉又不够好玩</p><p>于是计划用一个游标从头遍历到尾，这样的好处是不会重复发出多次op，在网络请求层面上还是要好一点的（游标有一个<code>batchSize</code>控制每次读取的数据量，可以视情况调整），而我又可以使用游标的流特性，来做一些下游打包、管道之类的好玩操作（见<a href="https://ngtmuzi.com/NodeJS%EF%BC%9AStream%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0II/">《Stream研究笔记II》</a>）</p><h2 id="延长查询超时时间"><a href="#延长查询超时时间" class="headerlink" title="延长查询超时时间"></a>延长查询超时时间</h2><blockquote><p><a href="http://mongodb.github.io/node-mongodb-native/3.5/api/MongoClient.html">官方文档-MongoClient</a></p></blockquote><p><code>MongoClient</code>建立实例时传递的<code>socketTimeoutMS</code>选项默认是6分钟，当查询耗时非常长时（比如没命中索引的<code>count()</code>），客户端将不再等待服务端返回并抛错，此选项只是以防万一，如果没有耗时很长的单次查询，这个可以保持默认</p><h2 id="设置游标不超时"><a href="#设置游标不超时" class="headerlink" title="设置游标不超时"></a>设置游标不超时</h2><blockquote><p><a href="http://mongodb.github.io/node-mongodb-native/3.5/api/Collection.html#find">官方文档-Collection.find()</a></p></blockquote><p>在<code>find()</code>的参数内传递<code>noCursorTimeout</code>，避免闲置的游标被服务端主动释放</p><h2 id="设置session活跃"><a href="#设置session活跃" class="headerlink" title="设置session活跃"></a>设置session活跃</h2><p>然而只靠上面的选项还不够，<a href="https://docs.mongodb.com/manual/reference/method/cursor.noCursorTimeout//">官方文档-cursor.noCursorTimeout</a> 又说了，服务端还是会清理闲置30分钟以上的<code>session</code>（每个<code>op</code>都包含在<code>session</code>中，不主动指定的话会生成一个隐式的），除非你主动地定期刷新<code>session</code>的活跃状态，连代码都附出来了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> session = db.<span class="title function_">getMongo</span>().<span class="title function_">startSession</span>()</span><br><span class="line"><span class="keyword">var</span> sessionId = session.<span class="title function_">getSessionId</span>().<span class="property">id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cursor = session.<span class="title function_">getDatabase</span>(<span class="string">&quot;examples&quot;</span>).<span class="title function_">getCollection</span>(<span class="string">&quot;data&quot;</span>).<span class="title function_">find</span>().<span class="title function_">noCursorTimeout</span>()</span><br><span class="line"><span class="keyword">var</span> refreshTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">// take note of time at operation start</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cursor.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if more than 5 minutes have passed since the last refresh</span></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">new</span> <span class="title class_">Date</span>()-refreshTimestamp)/<span class="number">1000</span> &gt; <span class="number">300</span> ) &#123;</span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&quot;refreshing session&quot;</span>)</span><br><span class="line">    db.<span class="title function_">adminCommand</span>(&#123;<span class="string">&quot;refreshSessions&quot;</span> : [sessionId]&#125;)</span><br><span class="line">    refreshTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// process cursor normally</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要自己显示声明一个<code>session</code>，在它之上发起游标查询，然后定期刷新<code>session</code>，这样游标就不会被服务器给释放掉了</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/%E7%BB%B4%E6%8C%81%E4%B8%80%E4%B8%AA%E8%B6%85%E9%95%BF%E6%97%B6%E9%97%B4%E7%9A%84mongodb%E6%B8%B8%E6%A0%87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NodeJS：Stream研究笔记II</title>
      <link>https://ngtmuzi.github.io/NodeJS%EF%BC%9AStream%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0II/</link>
      <guid>https://ngtmuzi.github.io/NodeJS%EF%BC%9AStream%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0II/</guid>
      <pubDate>Sun, 05 Apr 2020 12:19:39 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;几年前写的&lt;a href=&quot;/NodeJS：Stream研究笔记&quot;&gt;研究笔记&lt;/a&gt;现在回头看感觉全是在抄官方文档里的东西，近期真正在写stream的时候又发现其实根本没算了解，都没自己实现过读流和写流，于是补充一篇。&lt;/p&gt;
&lt;p&gt;以下内容主要来自官方文档及自行阅读源码，
        
      
      </description>
      
      <content:encoded><![CDATA[<p>几年前写的<a href="/NodeJS：Stream研究笔记">研究笔记</a>现在回头看感觉全是在抄官方文档里的东西，近期真正在写stream的时候又发现其实根本没算了解，都没自己实现过读流和写流，于是补充一篇。</p><p>以下内容主要来自官方文档及自行阅读源码，较多内部逻辑及细节已被省略，只抽象其主干思想：</p><h2 id="Readable可读流"><a href="#Readable可读流" class="headerlink" title="Readable可读流"></a>Readable可读流</h2><blockquote><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_readable_stream">官方文档-实现一个可读流</a></p></blockquote><ul><li>所有可读流都必须提供<code>_read()</code>方法的实现，以从基础资源中获取数据。</li><li>当调用<code>_read()</code>时，如果资源中已有可用数据，则应该使用<code>this.push(dataChunk)</code>将数据加入到读流的缓冲区队列中，然后<code>_read()</code>应该持续以上操作直到<code>push()</code>返回<code>false</code>。</li></ul><p><img src="/img/streamII-1.png" alt=""></p><p>从结论来说，如果你不调用<code>push()</code>，可读流永远不会产生数据。</p><p>关于可读流的两种读取模式在这里就不再赘述了，有趣的是可读流内部的缓冲区<code>buffer</code>并不是一个<code>Buffer</code>对象（因为流要支持对象模式，不能只支持二进制数据）或者<code>Array</code>，而是一个自己实现的单链表，带头尾指针，这里应该是考虑方便缓冲区的前后读写，并且不需要使用数组的索引功能。</p><p><code>push()</code>函数还提到说当它返回<code>false</code>时就不应该继续写入了，其实代码内部中只是返回了缓冲区与<code>highWaterMark</code>的大小对比，其实并不会抛弃超过的数据，所以自己实现时多写一些内容进去是没问题的（比如一次批量拿到了N个数据，总不能写一半丢一半）。</p><h2 id="Writable可写流"><a href="#Writable可写流" class="headerlink" title="Writable可写流"></a>Writable可写流</h2><blockquote><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_writable_stream">官方文档-实现一个可写流</a></p></blockquote><ul><li>所有可写流实现必须提供<code>_write</code>方法，以将数据发送到基础资源</li><li>必须调用回调方法来表示本次写入的成功或失败</li><li>在调用<code>_write()</code>和回调被调用之间如果有新的<code>write()</code>调用，则这些数据会先被放入缓冲区。调用回调时，流可能会发出“<code>drain</code>事件。</li></ul><p><img src="/img/streamII-2.png" alt=""></p><p>可写流相对比可读流逻辑简单一点，就是包裹一下用户自定义的写方法，并且做缓冲队列，从这里我们能知道很重要的一点：可写流的<code>write()</code>是串行调用的，不支持并发，因此才有了一个<code>writev()</code>方法作为批量写入的替代。<code>write()</code>返回的<code>true/false</code>也仅是表示数据量是否达到了它的水位线，但继续向其写入也是没问题的（当然要注意内存用量）。</p><h2 id="pipe方法"><a href="#pipe方法" class="headerlink" title="pipe方法"></a>pipe方法</h2><p>结合上面两张图之后再去看<code>pipe()</code>方法就会比较好理解了</p><p><img src="/img/streamII-3.png" alt=""></p><h2 id="Duplex双工流"><a href="#Duplex双工流" class="headerlink" title="Duplex双工流"></a>Duplex双工流</h2><blockquote><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_duplex_stream">官方文档-实现一个双工流</a></p></blockquote><p>就是简单继承了可读流和可写流而已，注意它并不是像一根水管一样一边写了一边就可以读，需要用户自己去实现读写方法，换言之你可以让流入和流出的数据完全无关。双工流与分开实现一个可读流一个可写流的区别，主要在于它可以帮你管理一些流的状态，比如<code>allowHalfOpen</code>不允许半开，这样读流触发<code>end</code>事件（如<code>push(null)</code>）时会去关闭写流。不过我们一般需求的场景是反过来的：写流end后就结束读流，但双工流无法实现，因为它没有与你约定好中间的数据流转逻辑，不知道读流何时才能正确被结束，因此我们一般使用它的子类<code>Transform</code>转换流。</p><h2 id="Transform转换流"><a href="#Transform转换流" class="headerlink" title="Transform转换流"></a>Transform转换流</h2><blockquote><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_transform_stream">官方文档-实现一个转换流</a></p></blockquote><ul><li><code>_transform()</code>可以当作是可写流的<code>_write()</code>的用途</li><li><code>_flush()</code>是上游流发出<code>end</code>事件时触发的方法，可以在这里将残余的中间数据处理并输出到下游去</li></ul><p>转换流是双工流的子类，封装了一些转换的逻辑，主要思路就是：</p><p>可写流<code>write()</code>接收数据 =&gt; _transform()方法 =&gt; push()方法 =&gt; 可读流产生数据输出</p><p>因为它本质上还是对可读流、可写流的封装，因此类似可写流的<code>highWaterMark</code>与串行写入实现的流速控制、<code>pipe()</code>管道方法等特性都是可以享受的，Node内常见的对流的加密压缩也都是用它实现的，注意的一点是<code>_transform()</code>方法本身是不会帮你把数据<code>push()</code>到可读流的（只有用户自己知道什么时候数据才是可以被输出的），因此要注意自己保留中间数据、及时调用<code>push()</code>输出、以及在<code>_flush()</code>接口内处理残余数据。</p><p><img src="/img/streamII-3.png" alt=""></p><p>这里附一个简单易懂的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将逐条数据缓存在内存，达到batchSize或上游流结束时，才向下游发出一条打包的data消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BatchStream</span> <span class="keyword">extends</span> <span class="title class_ inherited__">stream.Transform</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; batchSize 批量大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; options 传递给基类stream的options，部分属性固定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">batchSize = <span class="number">500</span>, options = &#123;&#125;</span>) &#123;</span><br><span class="line">    options.<span class="property">allowHalfOpen</span> = <span class="literal">false</span>;</span><br><span class="line">    options.<span class="property">writableObjectMode</span> = <span class="literal">true</span>;</span><br><span class="line">    options.<span class="property">readableObjectMode</span> = <span class="literal">true</span>;</span><br><span class="line">    options.<span class="property">highWaterMark</span>= <span class="number">1024</span>;</span><br><span class="line">    <span class="variable language_">super</span>(options);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">batchSize</span> = batchSize;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_chunks</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">_transform</span>(<span class="params">chunk, encoding, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_chunks</span> = <span class="variable language_">this</span>.<span class="property">_chunks</span>.<span class="title function_">concat</span>(chunk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_chunks</span>.<span class="property">length</span> &gt;= <span class="variable language_">this</span>.<span class="property">batchSize</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> batch = <span class="variable language_">this</span>.<span class="property">_chunks</span>.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">batchSize</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">push</span>(batch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">callback</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_flush</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_chunks</span>.<span class="property">length</span>) <span class="variable language_">this</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">_chunks</span>)</span><br><span class="line">    <span class="title function_">cb</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">BatchStream</span>;</span><br></pre></td></tr></table></figure><p>刚开始编写流的实现时可能要注意的一点是，流本身带有的那些数据缓冲区、写入队列并不是给你用的，因此如果要你保留一些中间状态，必须要自己建变量存着，比如上面例子的<code>this._chunks</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Node的流设计与Promise一样，本质上都是对回调、异步控制的封装和抽象，由于基于事件订阅的机制实现，它可以实现流速控制，更适合用于持续的异步过程，并可用<code>pipe()</code>管道方法将其简化，在使用中有以下点可以关注：</p><ul><li>可读流<code>on(&#39;data&#39;,cb)</code>形式订阅数据事件的形式，无法直接控制并发量，可以考虑用类似<a href="/Node对流的Promise包装和并发控制/">streamQueue</a>这样的形式再做一层控制，或者自己实现一个可写流，使用<code>pipe()</code>来做自动的流速控制</li><li>可写流的<code>write()</code>实际是串行处理写入数据，本身虽然保证了数据的有序性，但不一定高效，在追求效率的时候，可以考虑实现<code>_writev()</code>接口，或者不在<code>_write()</code>内等待异步执行，直接回调<code>cb</code>，如果出现问题想要中断流程，可以再手动触发错误<code>ws.emit(&#39;error&#39;)</code></li></ul>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/NodeJS%EF%BC%9AStream%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0II/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《凤凰项目》读书笔记</title>
      <link>https://ngtmuzi.github.io/%E3%80%8A%E5%87%A4%E5%87%B0%E9%A1%B9%E7%9B%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <guid>https://ngtmuzi.github.io/%E3%80%8A%E5%87%A4%E5%87%B0%E9%A1%B9%E7%9B%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 10 Sep 2019 12:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;部门老大推荐的一本书，全名《凤凰项目：一个IT运维的传奇故事》，一开始没注意看到副标题，光看主标题还以为是简单介绍如何做好项目管理和人员开发的书，类似《人月神话》。然而看了之后才发现是小说形式的，讲述一个新上任的IT运维部主管如何整理自己部门的烂摊子，并与开发、QA、内审、
        
      
      </description>
      
      <content:encoded><![CDATA[<p>部门老大推荐的一本书，全名《凤凰项目：一个IT运维的传奇故事》，一开始没注意看到副标题，光看主标题还以为是简单介绍如何做好项目管理和人员开发的书，类似《人月神话》。然而看了之后才发现是小说形式的，讲述一个新上任的IT运维部主管如何整理自己部门的烂摊子，并与开发、QA、内审、财务、运营…各个部门间有效合作最终挽救了一个失败项目的故事。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>故事并非发生在一个互联网公司，而是美国的一个传统的汽车制造业公司——“无极限公司”。开发和IT运维并非是该公司的核心部门，甚至由于他们历史上的效率低下和问题频出，公司已经开始考虑寻求外包解决方案，主角们面临被解雇的危机；而公司本身也处于风雨飘摇之中，友商新上线的产品推荐和个性化系统吸引了大量的客户，使得股市和董事会对公司多有微言，迫于压力无极限公司也开始研发类似的系统期望挽回客户，该项目称为“凤凰”。</p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>这本书并非只是单纯说如何完成“凤凰”这个项目的，主角是IT运维部门的主管，视角与我们一般的开发者不相同，全书并没有着眼与介绍一个软件项目是如何策划、开发、完成测试并上线的，而是从整个“传统制造业公司”的层面去审视运维工作流程、任务管理、各部门间的合作，并提出作者的一些观点。</p><h3 id="人和工作的管理"><a href="#人和工作的管理" class="headerlink" title="人和工作的管理"></a>人和工作的管理</h3><p>主角一上任就碰到了多次的系统故障，公司的工资发放、信用卡支付等重要功能受到影响，经过一系列流程梳理后，最终问题的焦点都在一个名为布伦特的人身上。他就是这个IT运维部的最核心员工，对业务流程的深入程度使得其他人甚至都帮不上忙，但也正因如此，很多变更操作他都没有经过审批而是自己直接操作，也因此产生了很多不可预估的系统故障。最后的结果是所有的重要流程都要由他操作，出现的各种故障也要找他来排查解决，他变成了整个部门最忙又最不可取代的一环。</p><p>主角团们发现了问题后，对其工作做出了分解，所有的服务器变更都必须拦下来，确认影响范围和优先级，并统一审核和安排时间实施，可以交由他人处理的工作就交由他人，他人尚不清楚的工作则由布伦特整理出工作流程。</p><p><em>这个情况在我们实际的工作中也是经常遇到的，总有一个人掌握了很多你不知道的黑科技，各种操作都需要他来帮忙，但他出问题时所有人只能看着他着急。这不是一个正常的工作情况，在严格的项目管控中，没有人具有不可替代性，需要把脑中的经验梳理并文档化，才能让他人参与进来；其次就是变更工作的管控，所有的变更能明确影响范围和审核必要性，对于稳定的线上环境是很重要的。</em></p><h4 id="IT的四类工作"><a href="#IT的四类工作" class="headerlink" title="IT的四类工作"></a>IT的四类工作</h4><ol><li>业务项目，如故事中的“凤凰”项目</li><li>IT内部项目，如各类发布、部署自动化系统</li><li>服务器变更，如常规的服务器迁移、数据库迁移等</li><li>计划外工作或救火工作</li></ol><p>短暂的“走捷径”或者绕过正规流程的操作会导致技术债务，技术债务的积累终将导致产生大量的计划外工作，最终使得处理人员再没有时间处理前3类计划内工作。因此我们需要及时地对流程进行规范和限制。</p><h3 id="用工厂流水线的眼光来看待软件开发"><a href="#用工厂流水线的眼光来看待软件开发" class="headerlink" title="用工厂流水线的眼光来看待软件开发"></a>用工厂流水线的眼光来看待软件开发</h3><p>书中的“贵人”埃瑞克一直在强调一点，就是IT开发运维流程的本质与工厂的流水线相同，开发、QA测试、运维发布等都是其中的数个环节，需要明确是哪个结点产生了工作的积压。但本书并不会告诉你如何“加大节点生产力”，毕竟人不是机器，堆量不一定能提高效率，这点在《人月神话》中会说得更清楚，本书提出的是如何在生产力有限的情况下，合理地安排工作流：</p><h4 id="三步工作法"><a href="#三步工作法" class="headerlink" title="三步工作法"></a>三步工作法</h4><ol><li>第一工作法是关于从开发到IT运维再到客户的整个自左向右的工作流。为了使流量最大化，我们需要小的批量规模和工作间隔</li><li>第二工作法是关于价值流各阶段自右向左的快速持续反馈流，放大其效益以确保问题再次发生，或者更快地发现和修复问题，从源头上保证质量</li><li>第三工作法是关于创造公司文化：鼓励探索、在失败中吸取教训；让员工理解重复的演练是重要的经验积累</li></ol><h3 id="敏捷开发和可持续交付"><a href="#敏捷开发和可持续交付" class="headerlink" title="敏捷开发和可持续交付"></a>敏捷开发和可持续交付</h3><p>书中有这样一段</p><blockquote><p>在竞争的时代，游戏规则就是“快速上市，快速淘汰”。我们不能为推出一个产品而制定为期几年的工作计划，一直等到最后才弄清手上拿的牌是赢家还是输家。我们需要短而快的周期，不断整合来自市场的反馈。<br>产品开发周期越长，公司资本锁定的时间也就越长，资金锁定期间是没有回报的。一旦研发资本以半成品的形式锁定超过一年而未向公司返还现金，它就几乎不可能再为公司产生回报了。</p></blockquote><p>书中很明确地提到的了一个开发周期为3年的项目对于公司来说相当于沉没成本，它持续耗费成本却不能产生任何价值，即使最后上线也有可能远远落后于竞品，这对于一家运营状况不好的公司来说是足以致命的，而敏捷开发不断给出可落地的成果，给予公司和市场信心，效果是会更好的。</p><h3 id="IT部门的定位"><a href="#IT部门的定位" class="headerlink" title="IT部门的定位"></a>IT部门的定位</h3><p>由于书中的公司并非一个互联网公司，软件开发、QA、运维等部门并非是营利的核心，很多时候运营、财务部门会认为IT部门是累赘，效率低且不能完成运营需求，但他们没考虑过IT部门的产出本身就是一个业务指标，IT部门运转情况也与公司的命脉息息相关。由IT引起的运营风险不只是IT风险，同样也是业务风险，需要将这些风险管控纳入业绩指标。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在读这本书前我也未曾考虑过高层次的问题，这本书能提供一定的眼界，纵观全局才能明晰问题所在，对于工作流程的一些观点也值得学习。</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/%E3%80%8A%E5%87%A4%E5%87%B0%E9%A1%B9%E7%9B%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用bash命令清理MSSQL内存</title>
      <link>https://ngtmuzi.github.io/%E4%BD%BF%E7%94%A8bash%E5%91%BD%E4%BB%A4%E6%B8%85%E7%90%86MSSQL%E5%86%85%E5%AD%98/</link>
      <guid>https://ngtmuzi.github.io/%E4%BD%BF%E7%94%A8bash%E5%91%BD%E4%BB%A4%E6%B8%85%E7%90%86MSSQL%E5%86%85%E5%AD%98/</guid>
      <pubDate>Wed, 03 Jul 2019 08:46:59 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;首先你得在windows环境上有一个bash环境，比如 &lt;a href=&quot;https://gitforwindows.org&quot;&gt;git-bash&lt;/a&gt; 或 &lt;a href=&quot;https://cygwin.com/index.html&quot;&gt;cygwin64&lt;/a&gt;&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>首先你得在windows环境上有一个bash环境，比如 <a href="https://gitforwindows.org">git-bash</a> 或 <a href="https://cygwin.com/index.html">cygwin64</a></p><p>加了一个是否有活跃sql会话的判断，避免搞出问题，sql语句部分来源于热心网友</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#释放mssql的内存</span></span><br><span class="line">. /etc/profile</span><br><span class="line"></span><br><span class="line">sessionNum=`osql -E -S . -Q <span class="string">&quot;select count(1) from sys.dm_exec_sessions where status!=&#x27;sleeping&#x27;&quot;</span> | sed -n 3p | <span class="built_in">tr</span> -d [:blank:] | <span class="built_in">tr</span> -d [:cntrl:]`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ `<span class="built_in">expr</span> <span class="variable">$sessionNum</span>` -ne 1 ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;存在正在执行的sql server会话，取消释放内存&quot;</span>;</span><br><span class="line"><span class="built_in">exit</span> 0;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">osql -E -S . -Q <span class="string">&quot;</span></span><br><span class="line"><span class="string">DBCC FREEPROCCACHE</span></span><br><span class="line"><span class="string">DBCC FREESESSIONCACHE</span></span><br><span class="line"><span class="string">DBCC FREESYSTEMCACHE(&#x27;All&#x27;)</span></span><br><span class="line"><span class="string">DBCC DROPCLEANBUFFERS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">USE master</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 打开高级设置配置 </span></span><br><span class="line"><span class="string">EXEC sp_configure &#x27;show advanced options&#x27;, 1</span></span><br><span class="line"><span class="string">RECONFIGURE WITH OVERRIDE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 先设置物理内存上限到1G </span></span><br><span class="line"><span class="string">EXEC sp_configure &#x27;max server memory (MB)&#x27;, 1024</span></span><br><span class="line"><span class="string">RECONFIGURE WITH OVERRIDE</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span> 10s</span><br><span class="line"></span><br><span class="line">osql -E -S . -Q <span class="string">&quot;</span></span><br><span class="line"><span class="string">-- 还原原先的上限 </span></span><br><span class="line"><span class="string">EXEC sp_configure &#x27;max server memory (MB)&#x27;, 25600</span></span><br><span class="line"><span class="string">RECONFIGURE WITH OVERRIDE</span></span><br><span class="line"><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/%E4%BD%BF%E7%94%A8bash%E5%91%BD%E4%BB%A4%E6%B8%85%E7%90%86MSSQL%E5%86%85%E5%AD%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Node开发命令行工具的经验总结</title>
      <link>https://ngtmuzi.github.io/Node%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</link>
      <guid>https://ngtmuzi.github.io/Node%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Mon, 11 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;近半年接手了一个非web开发类的工作，一直跟数据、数据库和脚本打交道，原项目是windows服bat脚本和.NET命令行程序来跑各种任务的。
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>近半年接手了一个非web开发类的工作，一直跟数据、数据库和脚本打交道，原项目是windows服bat脚本和.NET命令行程序来跑各种任务的。之前我没有太接触过shell这块，碰到这些bat脚本确实有点把我难到了，各方面相比bash来说还是有很大差距，于是我着手开始做迁移工作</p><p>这里推荐一个简单的bash入门教程</p><blockquote><p><a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md">bash-handbook</a></p></blockquote><p>而复杂逻辑的exe部分，还是用我熟悉的node.js来重构，在此之前我还没有过命令行的开发经验，算是摸着石头过河</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html">Node.js 命令行程序开发教程</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5af2a2cbf265da0b9c109f59">node.js 命令行工具(cli)</a></p></blockquote><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="链接为全局指令"><a href="#链接为全局指令" class="headerlink" title="链接为全局指令"></a>链接为全局指令</h3><p>大多数文档都会提到的一点，在<code>package.json</code>里的<code>bin</code>属性下写好指令名与代码路径后，执行<code>npm link</code>即可全局使用这个指令</p><h3 id="注意当前目录"><a href="#注意当前目录" class="headerlink" title="注意当前目录"></a>注意当前目录</h3><p>记得代码可能会在任意目录上执行，因此用相对定位来读自己的代码目录内的文件是不可取的，如<code>let s = fs.readFileSync(&#39;./a.json&#39;)</code></p><p>而应该改成使用<code>__dirname</code>来获取代码目录的绝对路径再去读文件，不过<code>require</code>函数不需要考虑这些，它会自己处理</p><h3 id="获取和解析参数"><a href="#获取和解析参数" class="headerlink" title="获取和解析参数"></a>获取和解析参数</h3><p>我参考了npm上较为主流的几款命令行模块，看到大多是与具体函数耦合较紧的，需要用代码来配置命令行解析参数，这样的好处是能实现很多高级功能，如默认值、参数验证、自动生成帮助文档等。</p><p>而我希望的是每次传不同的子命令时再去动态require代码，并且希望自定义帮助文档，因此只需要一套比较简单的解析库，拿到参数再自己处理，因此暂定使用了<a href="https://www.npmjs.com/package/yargs">yargs</a></p><h3 id="输出markdown文档到控制台"><a href="#输出markdown文档到控制台" class="headerlink" title="输出markdown文档到控制台"></a>输出markdown文档到控制台</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">&#x27;marked&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerminalRenderer</span> = <span class="built_in">require</span>(<span class="string">&#x27;marked-terminal&#x27;</span>);</span><br><span class="line"></span><br><span class="line">marked.<span class="title function_">setOptions</span>(&#123; <span class="attr">renderer</span>: <span class="keyword">new</span> <span class="title class_">TerminalRenderer</span>(&#123; <span class="attr">showSectionPrefix</span>: <span class="literal">false</span> &#125;) &#125;);</span><br><span class="line">process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="title function_">marked</span>(fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./readme.md&#x27;</span>)).<span class="title function_">toString</span>()));</span><br></pre></td></tr></table></figure><p><code>marked-terminal</code>模块将markdown文本转换为带有颜色信息的ANSI格式，然后输出到控制台，赏心悦目</p><p><img src="/img/node_cmd_1.jpg" alt="marked-terminal输出截图"></p><h3 id="从输入流读入数据"><a href="#从输入流读入数据" class="headerlink" title="从输入流读入数据"></a>从输入流读入数据</h3><p>想实现一个标准的UNIX类控制台程序，支持管道是必不可少的，得益于node的封装，我们有很简单的办法来获取输入流的数据</p><ul><li>从<a href="https://nodejs.org/dist/latest-v11.x/docs/api/process.html#process_process_stdin">process.stdin</a>流式读取数据，这个时候我之前写的<a href="/Node对流的Promise包装和并发控制/">Node对流的Promise包装和并发控制</a>模块就可以派上用场了</li><li>直接用<code>fs.readFileSync(0)</code>读取全部内容，<code>0</code>就是标准输入流的文件句柄，当然前提是数据量不大或者需要完整解析的情况（如json），否则我们还是流式处理比较好</li></ul><h3 id="调试信息定向到stderr"><a href="#调试信息定向到stderr" class="headerlink" title="调试信息定向到stderr"></a>调试信息定向到stderr</h3><p>想保持标准输出，又想在控制台看到调试日志的输出，我们可以将调试的数据都发到<code>stderr</code>去，最终的运行结果才输出到<code>stdout</code></p><p>在常用的日志模块<code>log4js</code>中，只要如此配置就好，这样所有日志输出都不会影响到标准输出流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log4js.<span class="title function_">configure</span>(&#123;</span><br><span class="line">  <span class="attr">appenders</span>: &#123; <span class="attr">err</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;stderr&#x27;</span> &#125; &#125;,</span><br><span class="line">  <span class="attr">categories</span>: &#123; <span class="attr">default</span>: &#123; <span class="attr">appenders</span>: [<span class="string">&#x27;err&#x27;</span>], <span class="attr">level</span>: <span class="string">&#x27;all&#x27;</span> &#125; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://log4js-node.github.io/log4js-node/stderr.html">log4js文档</a></p></blockquote><h3 id="注意等待输出流写完成再关闭进程"><a href="#注意等待输出流写完成再关闭进程" class="headerlink" title="注意等待输出流写完成再关闭进程"></a>注意等待输出流写完成再关闭进程</h3><p>如果有输出流或者日志文件的情况，要注意不要轻易调用<code>process.exit</code>来主动结束进程，要等待流写入文件完成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待流写入完成</span></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  ws.<span class="title function_">on</span>(<span class="string">&#x27;finish&#x27;</span>, resolve);</span><br><span class="line">  ws.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//node4js的处理进程</span></span><br><span class="line">log4js.<span class="title function_">shutdown</span>(cb);</span><br></pre></td></tr></table></figure><p>最好的情况是不写<code>process.exit</code>，只要记得<code>ws.end()</code>结束写入就行，当活动的流（包括标准输出流）全部完成，文件句柄释放后，进程自己会退出</p><h3 id="使用更大的内存"><a href="#使用更大的内存" class="headerlink" title="使用更大的内存"></a>使用更大的内存</h3><p>node.js使用的v8引擎默认堆内存上限约1.7GB，而在环境变量中加上<code>NODE_OPTIONS</code>=<code>--max-old-space-size=40960</code>后可以扩大可使用的内存大小，当然用大内存不一定是好事，优化代码、精简数据结构、流式处理和避免闭包才是合理做法</p><h3 id="使用烘焙-模板函数"><a href="#使用烘焙-模板函数" class="headerlink" title="使用烘焙/模板函数"></a>使用烘焙/模板函数</h3><p>在用一些模板或规则批量处理数据的时候，可以考虑使用预构建函数或烘焙模板来优化效率，前端的编译框架对这个就很有研究了，有兴趣可以了解下</p><h3 id="对CSV做SQL查询"><a href="#对CSV做SQL查询" class="headerlink" title="对CSV做SQL查询"></a>对CSV做SQL查询</h3><p>有些复杂的业务需求需要对文件做数据统计汇总，原先是用<a href="https://www.npmjs.com/package/lodash">lodash</a>的一套函数来处理，但未免还是有些繁复和难以阅读，后来引入了<a href="https://www.npmjs.com/package/alasql">alasql</a>，支持流式地对文件进行sql查询，甚至支持连表语法，我目前也还在初步尝试阶段，有相关需求的可以了解下</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>得益于现在基本所有前端渲染/JS预编译框架都会用Node的CLI工具来提供服务，npm上会有很多方便的模块供我们使用，在这之上使用Node来开发命令行工具还是很方便快捷的，在shell上如果有复杂的实现需求，不妨试试用Node编写代码来处理</p><p>关于控制台程序的一些理解和指导，推荐阅读《UNIX编程艺术》</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/Node%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Node对流的Promise包装和并发控制</title>
      <link>https://ngtmuzi.github.io/Node%E5%AF%B9%E6%B5%81%E7%9A%84Promise%E5%8C%85%E8%A3%85%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link>
      <guid>https://ngtmuzi.github.io/Node%E5%AF%B9%E6%B5%81%E7%9A%84Promise%E5%8C%85%E8%A3%85%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid>
      <pubDate>Tue, 06 Nov 2018 12:47:28 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;最近没有在做直接开发的工作，都是一些旧工作的接手和整理脚本流程之类的，发个之前写的函数吧。主要封装了流（或类似流的类，比如node.js自带的&lt;code&gt;readline&lt;/code&gt;模块）到&lt;code&gt;Promise&lt;/code&gt;中，并提供并发数控制的机制（当然需要流本身
        
      
      </description>
      
      <content:encoded><![CDATA[<p>最近没有在做直接开发的工作，都是一些旧工作的接手和整理脚本流程之类的，发个之前写的函数吧。主要封装了流（或类似流的类，比如node.js自带的<code>readline</code>模块）到<code>Promise</code>中，并提供并发数控制的机制（当然需要流本身支持pause才行）。我主要用于读数据库或文件之类的操作，将流的细节封起来感觉还是舒服一点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将可读流传给遍历器fn（可异步），使用流的特性做并发控制和收集返回（注意内存消耗）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> readable       &#123;ReadableStream&#125; 可读流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn             &#123;Function&#125;       遍历器，触发时机为data事件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> concurrency    &#123;Number&#125;         并发处理的数量，当并发数满时，流将会被自动暂停</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> collectResults &#123;Boolean&#125;        是否收集fn执行的结果，并最后返回结果的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eventName      &#123;String&#125;         事件名，一般是data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;      fn执行的次数或结果数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">streamQueue</span>(<span class="params">readable, fn, &#123; concurrency = <span class="number">1</span>, collectResults = <span class="literal">false</span>, eventName = <span class="string">&#x27;data&#x27;</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> runCount = <span class="number">0</span>, index = <span class="number">0</span>, isOver = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> results = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">checkFinish</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (isOver &amp;&amp; runCount === <span class="number">0</span>) <span class="title function_">resolve</span>(collectResults ? results : index);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    readable.<span class="title function_">on</span>(eventName, <span class="keyword">async</span> data =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> myIdx = index++;</span><br><span class="line">      runCount++;</span><br><span class="line">      <span class="keyword">if</span> (runCount &gt;= concurrency) readable.<span class="title function_">pause</span>();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">fn</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (collectResults) results[myIdx] = result;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      runCount--;</span><br><span class="line">      <span class="title function_">checkFinish</span>();</span><br><span class="line">      <span class="keyword">if</span> (runCount &lt; concurrency) readable.<span class="title function_">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    readable.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      isOver = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">checkFinish</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    readable.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      isOver = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">checkFinish</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    readable.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, reject);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/Node%E5%AF%B9%E6%B5%81%E7%9A%84Promise%E5%8C%85%E8%A3%85%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>mysql插入uuid主键时引起的死锁问题</title>
      <link>https://ngtmuzi.github.io/mysql%E6%8F%92%E5%85%A5uuid%E4%B8%BB%E9%94%AE%E6%97%B6%E5%BC%95%E8%B5%B7%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</link>
      <guid>https://ngtmuzi.github.io/mysql%E6%8F%92%E5%85%A5uuid%E4%B8%BB%E9%94%AE%E6%97%B6%E5%BC%95%E8%B5%B7%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 06 Nov 2018 12:45:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;很早之前稍微研究的结果&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;当表为空的时候，并发多个事务，先使用&lt;code&gt;for update&lt;/code&gt;来检
        
      
      </description>
      
      <content:encoded><![CDATA[<p>很早之前稍微研究的结果</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>当表为空的时候，并发多个事务，先使用<code>for update</code>来检查uuid是否存在，再insert记录，此时会引起多次死锁问题</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>用 <code>SHOW ENGINE INNODB STATUS;</code> 语句查看了最后一次死锁的记录后，找到这样一个解释：<br><a href="https://stackoverflow.com/questions/44949940/solution-for-insert-intention-locks-in-mysql">Solution for Insert Intention Locks in MySQL - stackoverflow</a><br>结合之前在各个国产博客上看到的知识点，大概总结起来就是：</p><ul><li>加锁时是在索引上加锁，这里搜索条件是主键uuid，使用的是主键索引</li><li>当锁定的值大于当前表内已存在的最大值时，实际上锁定的是这个最大值到无穷大的“间隙”</li><li>当同时有多个事务锁定这个间隙并尝试写入时，就会产生死锁</li><li>该问题容易出现在空表，毕竟表的数据越多，间隙也就越多，就越难同时锁定到同一间隙</li></ul><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>在处理事务的时候死锁还挺常见的，所以代码是必须要做兼容使其稍后重试的，也可以提高事务的隔离级别来解决，不过因为MongoDB4.0开始支持事务的原因，我转去用Mongo了~</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/mysql%E6%8F%92%E5%85%A5uuid%E4%B8%BB%E9%94%AE%E6%97%B6%E5%BC%95%E8%B5%B7%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>第一次面试官经验</title>
      <link>https://ngtmuzi.github.io/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%AE%98%E7%BB%8F%E9%AA%8C/</link>
      <guid>https://ngtmuzi.github.io/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%AE%98%E7%BB%8F%E9%AA%8C/</guid>
      <pubDate>Wed, 12 Sep 2018 12:51:53 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;被拉过去面应届生，都是互联网研发方向，技术栈全是清一色的JAVA+SMM开发，详情不细说，最后说下自己的感想吧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非本专业的还是吃亏，很多基础科目的知识会漏，程序员并不是只要会写一门语言就能当的&lt;/li&gt;
&lt;li&gt;无论是否有实习过，一般的应届生知识面
        
      
      </description>
      
      <content:encoded><![CDATA[<p>被拉过去面应届生，都是互联网研发方向，技术栈全是清一色的JAVA+SMM开发，详情不细说，最后说下自己的感想吧</p><ul><li>非本专业的还是吃亏，很多基础科目的知识会漏，程序员并不是只要会写一门语言就能当的</li><li>无论是否有实习过，一般的应届生知识面还是很窄的，很多工作中会遇到的问题和知识点还是没听说过</li><li>笔试那些考C语言奇技淫巧和数学推理的都是什么沙雕题，有些参考答案还是错的，改卷人也很水</li><li>面试主要还是看一个人“如何配得上这份工作”，所以一般学校里那种千篇一律的项目真的没什么吸引力</li><li>问题没法深入问，到后面基本都是“不是很了解”</li><li>新的技术和热点不是很关注，很少有博客和github以及开源项目</li></ul><p>最后脑子里一直就这句话<code>纸上得来终觉浅，绝知此事要躬行</code></p><p>面试别人比自己面试还累，喉咙都哑了，以后不干这个夭寿的活了</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%AE%98%E7%BB%8F%E9%AA%8C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>实现一个嵌套对象式的路由中间件</title>
      <link>https://ngtmuzi.github.io/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1%E5%BC%8F%E7%9A%84%E8%B7%AF%E7%94%B1%E4%B8%AD%E9%97%B4%E4%BB%B6/</link>
      <guid>https://ngtmuzi.github.io/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1%E5%BC%8F%E7%9A%84%E8%B7%AF%E7%94%B1%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid>
      <pubDate>Fri, 15 Jun 2018 08:17:52 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;不喜欢命令式地一行行声明路由和处理函数，也觉得&lt;code&gt;koa&lt;/code&gt;栈的各类路由中间件不好用，所以就想着自己做个玩&lt;/p&gt;
&lt;h2
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>不喜欢命令式地一行行声明路由和处理函数，也觉得<code>koa</code>栈的各类路由中间件不好用，所以就想着自己做个玩</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="对象路径-路由路径，无next逻辑"><a href="#对象路径-路由路径，无next逻辑" class="headerlink" title="对象路径=路由路径，无next逻辑"></a>对象路径=路由路径，无next逻辑</h3><p>这个中间件的定位相当于最终路由，不支持内部的多层next的结构（但有提供框架本身的next参数），也不考虑RESTful的实现，所以代码还是挺简单的（要实现RESTful可以在处理函数内自己加判断，或者多做一层代理）</p><h3 id="msg-路由参数-query-body"><a href="#msg-路由参数-query-body" class="headerlink" title="msg=路由参数+query+body"></a>msg=路由参数+query+body</h3><p>所有参数都从msg一个对象里取，类似<code>ASP.NET</code>的做法，在大多数情况下能方便开发，当然要想分别从不同地方取也是可以的</p><h3 id="接受异步返回-promise"><a href="#接受异步返回-promise" class="headerlink" title="接受异步返回(promise)"></a>接受异步返回(promise)</h3><p>得益于Node8.0+的<code>async/await</code>特性支持，我们终于可以写优雅的异步代码了（<code>koa</code>自身支持，不过<code>express</code>还是要加点处理）</p><h3 id="统一的输出控制-错误捕获层"><a href="#统一的输出控制-错误捕获层" class="headerlink" title="统一的输出控制/错误捕获层"></a>统一的输出控制/错误捕获层</h3><p>大多数项目都会想要一个统一的输出/错误处理层，所以提供了这个逻辑</p><h3 id="支持路由参数"><a href="#支持路由参数" class="headerlink" title="支持路由参数"></a>支持路由参数</h3><p>参考了<code>express</code>的实现代码引入<code>path-to-regexp</code>模块，可以写一些很cool的路由了</p><h3 id="koa与express都支持"><a href="#koa与express都支持" class="headerlink" title="koa与express都支持"></a>koa与express都支持</h3><p>代码暂时还是分开维护的，毕竟两个框架实现上还是有很大不同</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>反正我在生产环境用了挺久的，具体用法可以参考下面的链接</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://github.com/ngtmuzi/nRouter">Github-nRouter</a><br>暂时没有发布npm的打算（写英文好累的）</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1%E5%BC%8F%E7%9A%84%E8%B7%AF%E7%94%B1%E4%B8%AD%E9%97%B4%E4%BB%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>javaScript实现一个分数计算的类</title>
      <link>https://ngtmuzi.github.io/javaScript%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E6%95%B0%E8%AE%A1%E7%AE%97%E7%9A%84%E7%B1%BB/</link>
      <guid>https://ngtmuzi.github.io/javaScript%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E6%95%B0%E8%AE%A1%E7%AE%97%E7%9A%84%E7%B1%BB/</guid>
      <pubDate>Fri, 25 May 2018 07:48:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;一开始实现的时候钻到了牛角尖里，还想着要保留复杂分式的所有结构，那就要构建成树还要做递归遍历，各种计算也复杂得要死，后来想了一下每次计算都直接化成最简式不就好了&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>一开始实现的时候钻到了牛角尖里，还想着要保留复杂分式的所有结构，那就要构建成树还要做递归遍历，各种计算也复杂得要死，后来想了一下每次计算都直接化成最简式不就好了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> &#123;<span class="type">Number</span>&#125; numerator  分子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> &#123;<span class="type">Number</span>&#125; denominator  分母</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 可以接受数值和分式</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Number|Fraction</span>&#125; <span class="variable">numerator</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Number|Fraction</span>&#125; <span class="variable">denominator</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Fraction</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">numerator, denominator = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(numerator) &amp;&amp; <span class="title class_">Number</span>.<span class="title function_">isInteger</span>(denominator)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">numerator</span>   = numerator;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">denominator</span> = denominator;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numerator <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> || denominator <span class="keyword">instanceof</span> <span class="title class_">Fraction</span>) &#123;</span><br><span class="line">      numerator   = numerator <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> ? numerator : <span class="keyword">new</span> <span class="title class_">Fraction</span>(numerator, <span class="number">1</span>);</span><br><span class="line">      denominator = denominator <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> ? denominator : <span class="keyword">new</span> <span class="title class_">Fraction</span>(denominator, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> numerator.<span class="title function_">clone</span>().<span class="title function_">divide</span>(denominator);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;prams must be Number or Fraction&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">simplify</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 辗转相除法求最大公约数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">num1</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">num2</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greatestCommonDivisor</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lesser  = <span class="title class_">Math</span>.<span class="title function_">abs</span>(num1);</span><br><span class="line">    <span class="keyword">let</span> greater = <span class="title class_">Math</span>.<span class="title function_">abs</span>(num2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lesser !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> t   = lesser;</span><br><span class="line">      lesser  = greater % lesser;</span><br><span class="line">      greater = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> greater;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">clone</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fraction</span>(<span class="variable language_">this</span>.<span class="property">numerator</span>, <span class="variable language_">this</span>.<span class="property">denominator</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 化简分式</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Fraction</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">simplify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> gcd        = <span class="title class_">Fraction</span>.<span class="title function_">greatestCommonDivisor</span>(<span class="variable language_">this</span>.<span class="property">numerator</span>, <span class="variable language_">this</span>.<span class="property">denominator</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">numerator</span>   = <span class="variable language_">this</span>.<span class="property">numerator</span> / gcd;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">denominator</span> = <span class="variable language_">this</span>.<span class="property">denominator</span> / gcd;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 导出格式  a/b</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.numerator&#125;</span>/<span class="subst">$&#123;<span class="variable language_">this</span>.denominator&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从字符串解析出分式，支持 1/3 和  3 的格式</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">str</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Fraction</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">fromString</span>(<span class="params">str = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>).<span class="title function_">filter</span>(<span class="title class_">Number</span>.<span class="property">isInteger</span>);</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> === <span class="number">1</span>) arr.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> !== <span class="number">2</span>) <span class="keyword">throw</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;params must be 2 Integer spread by &quot;/&quot;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fraction</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">numerator</span> / <span class="variable language_">this</span>.<span class="property">denominator</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">add</span>(<span class="params">frac1, frac2</span>) &#123;</span><br><span class="line">    frac1 = frac1 <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> ? frac1.<span class="title function_">clone</span>() : <span class="keyword">new</span> <span class="title class_">Fraction</span>(frac1);</span><br><span class="line">    frac2 = frac2 <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> ? frac2.<span class="title function_">clone</span>() : <span class="keyword">new</span> <span class="title class_">Fraction</span>(frac2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  a/b + c/d = (a*d+b*c) / b*d</span></span><br><span class="line">    frac1.<span class="property">numerator</span>   = frac1.<span class="property">numerator</span> * frac2.<span class="property">denominator</span> + frac1.<span class="property">denominator</span> * frac2.<span class="property">numerator</span>;</span><br><span class="line">    frac1.<span class="property">denominator</span> = frac1.<span class="property">denominator</span> * frac2.<span class="property">denominator</span>;</span><br><span class="line">    <span class="keyword">return</span> frac1.<span class="title function_">simplify</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">frac</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Fraction</span>.<span class="title function_">add</span>(<span class="variable language_">this</span>, frac);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">subtract</span>(<span class="params">frac1, frac2</span>) &#123;</span><br><span class="line">    frac1 = frac1 <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> ? frac1.<span class="title function_">clone</span>() : <span class="keyword">new</span> <span class="title class_">Fraction</span>(frac1);</span><br><span class="line">    frac2 = frac2 <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> ? frac2.<span class="title function_">clone</span>() : <span class="keyword">new</span> <span class="title class_">Fraction</span>(frac2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  a/b + c/d = (a*d-b*c) / b*d</span></span><br><span class="line">    frac1.<span class="property">numerator</span>   = frac1.<span class="property">numerator</span> * frac2.<span class="property">denominator</span> - frac1.<span class="property">denominator</span> * frac2.<span class="property">numerator</span>;</span><br><span class="line">    frac1.<span class="property">denominator</span> = frac1.<span class="property">denominator</span> * frac2.<span class="property">denominator</span>;</span><br><span class="line">    <span class="keyword">return</span> frac1.<span class="title function_">simplify</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subtract</span>(<span class="params">frac</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Fraction</span>.<span class="title function_">subtract</span>(<span class="variable language_">this</span>, frac);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">multiply</span>(<span class="params">frac1, frac2</span>) &#123;</span><br><span class="line">    frac1 = frac1 <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> ? frac1.<span class="title function_">clone</span>() : <span class="keyword">new</span> <span class="title class_">Fraction</span>(frac1);</span><br><span class="line">    frac2 = frac2 <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> ? frac2.<span class="title function_">clone</span>() : <span class="keyword">new</span> <span class="title class_">Fraction</span>(frac2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (a/b)*(c/d) = (a*b)/(c*d)</span></span><br><span class="line">    frac1.<span class="property">numerator</span>   = frac1.<span class="property">numerator</span> * frac2.<span class="property">numerator</span>;</span><br><span class="line">    frac1.<span class="property">denominator</span> = frac1.<span class="property">denominator</span> * frac2.<span class="property">denominator</span>;</span><br><span class="line">    <span class="keyword">return</span> frac1.<span class="title function_">simplify</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">multiply</span>(<span class="params">frac</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Fraction</span>.<span class="title function_">multiply</span>(<span class="variable language_">this</span>, frac);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">divide</span>(<span class="params">frac1, frac2</span>) &#123;</span><br><span class="line">    frac1 = frac1 <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> ? frac1.<span class="title function_">clone</span>() : <span class="keyword">new</span> <span class="title class_">Fraction</span>(frac1);</span><br><span class="line">    frac2 = frac2 <span class="keyword">instanceof</span> <span class="title class_">Fraction</span> ? frac2.<span class="title function_">clone</span>() : <span class="keyword">new</span> <span class="title class_">Fraction</span>(frac2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  (a/b) / (c/d) = (a*d) / (b*c)</span></span><br><span class="line">    frac1.<span class="property">numerator</span>   = frac1.<span class="property">numerator</span> * frac2.<span class="property">denominator</span>;</span><br><span class="line">    frac1.<span class="property">denominator</span> = frac1.<span class="property">denominator</span> * frac2.<span class="property">numerator</span>;</span><br><span class="line">    <span class="keyword">return</span> frac1.<span class="title function_">simplify</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">divide</span>(<span class="params">frac</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Fraction</span>.<span class="title function_">divide</span>(<span class="variable language_">this</span>, frac);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务代码写得多了居然连这种简单的功能代码都生疏了，老了老了，原来计划的每月一篇博客肯定是鸽了</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/javaScript%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E6%95%B0%E8%AE%A1%E7%AE%97%E7%9A%84%E7%B1%BB/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Node实现简单的redis同步锁</title>
      <link>https://ngtmuzi.github.io/Node%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84redis%E5%90%8C%E6%AD%A5%E9%94%81/</link>
      <guid>https://ngtmuzi.github.io/Node%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84redis%E5%90%8C%E6%AD%A5%E9%94%81/</guid>
      <pubDate>Thu, 22 Mar 2018 06:07:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;也是实际的需求，某个业务有并发问题，同时处理会引起脏读脏写，之前实现了一个&lt;a href=&quot;https://ngtmuzi.com/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%
        
      
      </description>
      
      <content:encoded><![CDATA[<p>也是实际的需求，某个业务有并发问题，同时处理会引起脏读脏写，之前实现了一个<a href="https://ngtmuzi.com/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%E9%98%9F%E5%88%97/">promise队列</a>就是来解决这件事的，但现在服务器部署了多台，业务方随机访问，没办法在内存层面做到队列控制了，因此就想到用redis来实现一个简单锁来控制并发</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://redis.io/topics/distlock">Distributed locks with Redis</a></p></blockquote><p>来自官网上redis作者的文章，虽然是讲分布式锁redLock的，但也提到了使用redis实现简单锁的方法，并提出了他认为的简单锁的缺点：</p><ul><li>单点故障</li><li>有部署主从的情况下，可能主服上的锁定操作还没同步到从服，主服就出现了故障，从服晋升为主服，使得之前的锁定不生效</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在我这边的实际业务上看，redis的故障是可以容忍的，实话说我接触了redis挺长一段时间还从没见它崩过，因此就直接照着作者的思路来实现一个简单锁就好了：</p><ol><li>客户端使用<code>SET NX</code>语法设置一个会过期的键，当键存在时返回锁定错误（即表明已经这个键已经被别人锁着了） <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure></li><li>解锁时向redis服调用一段<code>lua</code>脚本 <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure> 解锁时传递的value必须与锁定时的value相等，这是用于防止其他客户端在错误情况下会解锁其他人锁的情况，就是“解铃还须系铃人”的那种感觉</li><li>若超过过期时间，客户端还没发起解锁，那么该键将会因为过期而被redis删除，避免产生死锁的情况</li><li>更完善一点实现还会考虑加时的情况，即延长自己的锁定时间，也需要用lua脚本来做判断value是否相等</li></ol><h2 id="Node代码实现"><a href="#Node代码实现" class="headerlink" title="Node代码实现"></a>Node代码实现</h2><p>使用<a href="https://www.npmjs.com/package/ioredis">ioredis模块</a></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Locker</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">redis</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">redis</span>   = redis;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lockMap</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义lua脚本让它原子化执行</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">redis</span>.<span class="title function_">defineCommand</span>(<span class="string">&#x27;lua_unlock&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">numberOfKeys</span>: <span class="number">1</span>,</span><br><span class="line">      lua         : <span class="string">`</span></span><br><span class="line"><span class="string">        local remote_value = redis.call(&quot;get&quot;,KEYS[1])</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        if (not remote_value) then</span></span><br><span class="line"><span class="string">          return 0</span></span><br><span class="line"><span class="string">        elseif (remote_value == ARGV[1]) then</span></span><br><span class="line"><span class="string">          return redis.call(&quot;del&quot;,KEYS[1])</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">          return -1</span></span><br><span class="line"><span class="string">        end`</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递一个ioredis实例进来，<code>lockMap</code>用来在内存在维护多组锁定相关的键值对，使用ioredis的功能定义一个解锁用的lua脚本以待后面调用，脚本稍微增加了一点内容</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁定key，如已被锁定会抛错</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expire    过期时间(毫秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise&lt;void&gt;</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">lock</span>(<span class="params">key, expire = <span class="number">10000</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = crypto.<span class="title function_">randomBytes</span>(<span class="number">16</span>).<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">redis</span>.<span class="title function_">set</span>(key, value, <span class="string">&#x27;NX&#x27;</span>, <span class="string">&#x27;PX&#x27;</span>, expire);</span><br><span class="line">  <span class="keyword">if</span> (result === <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;lock error: key already exists&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lockMap</span>.<span class="title function_">set</span>(key, &#123;value, expire, <span class="attr">time</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>()&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;OK&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一个随机值做value，写入redis和内存中</p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解锁key，无论key是否存在，解锁是否成功，都不会抛错（除网络原因外），具体返回值:</span></span><br><span class="line"><span class="comment"> * null: key在本地不存在    0:key在redis上不存在    1:解锁成功      -1:value不对应，不能解锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise&lt;*&gt;</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">unLock</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">lockMap</span>.<span class="title function_">has</span>(key)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> &#123;value, expire, time&#125; = <span class="variable language_">this</span>.<span class="property">lockMap</span>.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lockMap</span>.<span class="title function_">delete</span>(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">redis</span>.<span class="title function_">lua_unlock</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从内存中找到对应key的value，把它们传给redis，使用lua脚本解锁，因为解锁基本算是个收尾的工作，因此各种没解锁成功的情况我不会抛错，有需要可以根据返回值自己处理</p><h3 id="等待加锁"><a href="#等待加锁" class="headerlink" title="等待加锁"></a>等待加锁</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每隔interval时间就尝试一次锁定，当用时超过waitTime就返回失败</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">expire</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">interval</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">waitTime</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Promise&lt;void&gt;</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">waitLock</span>(<span class="params">key, expire, interval = <span class="number">500</span>, waitTime = <span class="number">5000</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> start_time = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">while</span> ((<span class="title class_">Date</span>.<span class="title function_">now</span>() - start_time) &lt; waitTime) &#123;</span><br><span class="line">    result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">lock</span>(key, expire).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">    <span class="keyword">if</span> (result === <span class="string">&#x27;OK&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;OK&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">await</span> <span class="title function_">delay</span>(interval);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;waitLock timeout&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待一段时间（毫秒）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">ms</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对键重复地尝试加锁，直到抢占到锁资源，类似“连接池”的那种感觉</p><p><a href="https://github.com/ngtmuzi/wheel/blob/master/services/redisLocker.js">完整代码</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redisLock的逻辑有点太复杂了，一般业务用简单的同步锁就好了</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/Node%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84redis%E5%90%8C%E6%AD%A5%E9%94%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2017年终小结</title>
      <link>https://ngtmuzi.github.io/2017%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93/</link>
      <guid>https://ngtmuzi.github.io/2017%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93/</guid>
      <pubDate>Mon, 08 Jan 2018 13:11:33 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;2017年刚开始的时候写年度目标，是每月至少一篇博客，结果到最后还是没坚持下来，但随便找些东西充数，好像也不好&lt;/p&gt;
&lt;p&gt;主要是最后几个月开始把一个完全无关的项目硬合并到原先在维护的项目里，我开始庆幸原项目被我重构了2次，框架封装得还算可以，因此接入新的功能也不难&lt;/p
        
      
      </description>
      
      <content:encoded><![CDATA[<p>2017年刚开始的时候写年度目标，是每月至少一篇博客，结果到最后还是没坚持下来，但随便找些东西充数，好像也不好</p><p>主要是最后几个月开始把一个完全无关的项目硬合并到原先在维护的项目里，我开始庆幸原项目被我重构了2次，框架封装得还算可以，因此接入新的功能也不难</p><p>难点在于协调别人写的代码，表面上说遵守你的开发规范，但提交代码总是一堆的warn+error，还要图方便弄出一些“封装函数”，把抛出的错误都内部消化</p><p>不过工作大概都是这样吧，习惯就好了</p><h2 id="工作小结"><a href="#工作小结" class="headerlink" title="工作小结"></a>工作小结</h2><h3 id="JS方面的"><a href="#JS方面的" class="headerlink" title="JS方面的"></a>JS方面的</h3><ul><li>自己出于好玩写的一个路由模块在<code>express</code>上用顺手了，也在<code>koa</code>上实现了一遍，觉得还可以，有时间再整理下放github上</li><li>前后端基本都改用async/await写法了，效率比之前高了不少</li><li>VUE2抽空把官方的文档看完了，试了一下几个前端的VUE框架/脚手架，还挺好玩的，不过webpack还是没仔细研究</li></ul><h3 id="其他方面的"><a href="#其他方面的" class="headerlink" title="其他方面的"></a>其他方面的</h3><ul><li>docker年中的时候研究了一阵，不过正式环境没用上</li><li>rabbitmq在正式服炸了几次，难受，不过升级了版本之后就没出现了，另外那个Shovel方式来做集群的方式很好用，做cluster集群炸过一次有阴影了</li><li>redis今年在正式服搭了个分片+主从的集群，步骤还算简单但是要跑起来命令行工具挺麻烦</li><li>mongodb今年在正式服搭了复制集，自动切换主从没出过问题，还行</li><li>elk今年用来做了日志收集分析，挺好用也挺强大的工具，不过挺吃硬件资源</li><li>研究了一下区块链，不过感觉虚拟货币交易的精髓应该是UTXO而不是一直在鼓吹的区块链</li><li>iptables那一套还是不懂</li><li>变成老油条了</li></ul><h2 id="生活小结"><a href="#生活小结" class="headerlink" title="生活小结"></a>生活小结</h2><ul><li>搬了个宿舍可以拉窗帘睡觉了</li><li>斗鱼房间解封之后晚上可以开直播了</li><li>想回家</li></ul><h2 id="关于2018"><a href="#关于2018" class="headerlink" title="关于2018"></a>关于2018</h2><p>本命年已经过了不过没发生什么改变，也过了《九局下半》的年纪，感觉已经三振出局了</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/2017%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PWA脚手架Lavas试用小结</title>
      <link>https://ngtmuzi.github.io/PWA%E8%84%9A%E6%89%8B%E6%9E%B6Lavas%E8%AF%95%E7%94%A8%E5%B0%8F%E7%BB%93/</link>
      <guid>https://ngtmuzi.github.io/PWA%E8%84%9A%E6%89%8B%E6%9E%B6Lavas%E8%AF%95%E7%94%A8%E5%B0%8F%E7%BB%93/</guid>
      <pubDate>Mon, 18 Sep 2017 08:48:14 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;基本摘自&lt;a href=&quot;https://lavas.baidu.com&quot;&gt;Lavas官网&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是PWA&quot;&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>基本摘自<a href="https://lavas.baidu.com">Lavas官网</a></p><h3 id="什么是PWA"><a href="#什么是PWA" class="headerlink" title="什么是PWA"></a><a href="https://lavas.baidu.com/doc">什么是PWA</a></h3><p>Progressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。</p><p>PWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。</p><p>PWA 的主要特点包括下面三点：</p><ul><li>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现</li><li>体验 - 快速响应，并且有平滑的动画响应用户的操作</li><li>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面</li></ul><h3 id="Lavas-是什么"><a href="#Lavas-是什么" class="headerlink" title="Lavas 是什么"></a><a href="https://lavas.baidu.com/guide">Lavas 是什么</a></h3><p>Lavas 是一个基于 Vue 的 PWA (Progressive Web Apps) 完整解决方案。我们将 PWA 的工程实践总结成多种 Lavas 应用框架模板，帮助开发者轻松搭建 PWA 站点，且无需过多的关注 PWA 开发本身。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g lavas</span><br><span class="line">lavas init</span><br></pre></td></tr></table></figure><p>lavas的命令行工具提供了挺多的步骤流程来配置工程，还都是中文，这点很舒服</p><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>我们这里谈论的是appshell模板</p><p>lavas并没有引入过多的抽象概念，基本类似一个普通的vue单页应用脚手架，不过提供了一套通用的静态文件缓存/更新的方案，使我们不需要任何配置就可以实现基本的静态文件缓存功能，这点很赞</p><h3 id="AppShell"><a href="#AppShell" class="headerlink" title="AppShell"></a>AppShell</h3><p>这是谷歌提出来的一个<a href="https://developers.google.cn/web/fundamentals/architecture/app-shell">概念</a>，而lavas的解释如下</p><blockquote><p>App Shell 架构是构建 PWA 应用的一种方式，它通常提供了一个最基本的 Web App 框架，包括应用的头部、底部、菜单栏等结构。顾名思义，我们可以把它理解成应用的一个「空壳」，这个「空壳」仅包含页面框架所需的最基本的 HTML 片段，CSS 和 javaScript，这样一来，用户重复打开应用时就能迅速地看到 Web App 的基本界面，只需要从网络中请求、加载必要的内容。我们使用 Service Worker 对 App Shell 做离线缓存，以便它可以在离线时正常展现，达到类似 Native App 的体验。</p></blockquote><p>在lavas工程里，它体现为页面的顶部导航、底部导航和侧边栏等组件以及配套的一系列vuex的action和mutation，还有路由中的一些前进/后退的处理逻辑，使我们可以像Native App一样不需要关心细节就可以很简单地修改它们的状态来适应自己的具体需求</p><h3 id="ServiceWorker"><a href="#ServiceWorker" class="headerlink" title="ServiceWorker"></a>ServiceWorker</h3><p>这也是谷歌的PWA框架中提出来的<a href="https://developers.google.cn/web/fundamentals/getting-started/primers/service-workers">概念</a>，lavas的解释如下</p><blockquote><p>Service Worker 是用 JavaScript 编写的 JS 文件，能够代理请求，并且能够操作浏览器缓存，通过将缓存的内容直接返回，让请求能够瞬间完成。开发者可以预存储关键文件，可以淘汰过期的文件等等，给用户提供可靠的体验。</p></blockquote><p>可以说pwa能做到缓存离线静态文件或其他离线内容就是靠它来控制的，然而处理不好你可能会碰上复杂的缓存不能及时更新的问题，lavas提供了通用的方案来帮助我们缓存static目录内的文件和实现更新功能，在简单情况下我们甚至不需要去在意这个概念就可以开发出pwa应用</p><h3 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h3><p>都是谷歌提出的<a href="https://developers.google.cn/web/fundamentals/getting-started/codelabs/your-first-pwapp/#_30">概念</a></p><blockquote><p>网络应用清单是一个简单的 JSON 文件，使您（开发者）能够控制在用户可能看到应用的区域（例如手机主屏幕）中如何向用户显示应用，指示用户可以启动哪些功能，更重要的是说明启动方法。</p><p>利用网络应用清单，您的网络应用可以：</p><ul><li>在用户的 Android 主屏幕进行丰富的呈现</li><li>在没有网址栏的 Android 设备上以全屏模式启动</li><li>控制屏幕方向以获得最佳查看效果</li><li>定义网站的“启动画面”启动体验和主题颜色</li><li>追踪您是从主屏幕还是从网址栏启动</li></ul></blockquote><p>使用它才能实现在手机上添加主屏图标和自定义启动页的功能，lavas已提供了默认文件，在此基础上修改就行</p><h3 id="vuetifyjs"><a href="#vuetifyjs" class="headerlink" title="vuetifyjs"></a>vuetifyjs</h3><p>lavas使用的UI组件库是遵循MD设计的<a href="https://vuetifyjs.com/vuetify/quick-start">vuetifyjs库</a>，并非国内常用的框架库，接入可能需要一点理解成本</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="没有集中的配置文件"><a href="#没有集中的配置文件" class="headerlink" title="没有集中的配置文件"></a>没有集中的配置文件</h3><p>一部分主题配置在config目录中，路由配置在src中，标题和页面主题色等常用配置居然是写死在index.html里的，这点就像一个普通的spa脚手架，缺少一个地方来设置一些常用配置</p><h3 id="vuetifyjs-1"><a href="#vuetifyjs-1" class="headerlink" title="vuetifyjs"></a>vuetifyjs</h3><p>正在频繁更新，还没出1.0版，谨慎使用，不过文档还算完善</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lavas确实能使我们不需要在意底层的细节就可以快速开发出pwa应用，当然要深入的话还是要去了解相关知识点的，百度在这一点做得很好，官方文档不仅包括lavas的，还包括整个pwa的介绍，十分全面</p><p>唯一奇怪的是github星数居然不到200，怕是没怎么宣传，不过看到有子模块还在频繁更新，我们可以期待未来的发展</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/PWA%E8%84%9A%E6%89%8B%E6%9E%B6Lavas%E8%AF%95%E7%94%A8%E5%B0%8F%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nuxt.js试用小结</title>
      <link>https://ngtmuzi.github.io/Nuxt-js%E8%AF%95%E7%94%A8%E5%B0%8F%E7%BB%93/</link>
      <guid>https://ngtmuzi.github.io/Nuxt-js%E8%AF%95%E7%94%A8%E5%B0%8F%E7%BB%93/</guid>
      <pubDate>Mon, 04 Sep 2017 01:39:13 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;以下为个人使用&lt;code&gt;Nuxt.js&lt;/code&gt;的一些体会总结，并不全面，并且该项目还在频繁更新中（目前是v1.0.0-rc8），文档/中文文档并不完善，可以在小项目中先试手&lt;/p&gt;
&lt;h2 id=&quot;什么是Nuxt-js&quot;&gt;&lt;a href=&quot;#什么是Nuxt-js&quot; 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>以下为个人使用<code>Nuxt.js</code>的一些体会总结，并不全面，并且该项目还在频繁更新中（目前是v1.0.0-rc8），文档/中文文档并不完善，可以在小项目中先试手</p><h2 id="什么是Nuxt-js"><a href="#什么是Nuxt-js" class="headerlink" title="什么是Nuxt.js"></a>什么是<code>Nuxt.js</code></h2><p><a href="https://nuxtjs.org/guide">Nuxt.js官网</a></p><blockquote><p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。<br>通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。<br>我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。<br>Nuxt.js 预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。</p></blockquote><p>可以把它认为是更完善的vue开发脚手架，但比之脚手架它提供了更多概念上的抽象定义，也实现了一些更高级的特性诸如服务端渲染</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方推荐使用<code>vue-cli</code>来安装<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vue init nuxt/starter &lt;project-name&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>主要摘录和总结自官方文档，但由于文档/中文文档更新速度没更上代码的速度，可能有部分出入</p><h3 id="页面-page"><a href="#页面-page" class="headerlink" title="页面(page)"></a>页面(page)</h3><p>本质是vue组件，其文件在pages目录中的所处的路径决定了在url中访问的路径，并且<code>Nuxt.js</code>在其中新增了一些新属性，<a href="https://nuxtjs.org/guide/views#pages">官方文档</a></p><p>比较需要注意的就是<code>asyncData</code>和<code>layout</code>，前者用于在显示页面前获取异步的数据，后者指定渲染的布局</p><h3 id="asyncData方法"><a href="#asyncData方法" class="headerlink" title="asyncData方法"></a>asyncData方法</h3><p><a href="https://nuxtjs.org/api">官方文档</a></p><p>在<code>page</code>组件传入vue渲染前会调用<code>asyncData</code>方法，其接受<code>Promise</code>的返回，当然现在更好的选择是使用<code>async/await</code>特性，最终返回的结果会并入<code>page</code>组件的<code>data</code>属性中</p><p>注意该方法传递的第一个参数是<code>Nuxt.js</code>提供的该页面的<code>context</code>对象，其提供了不少常用的属性和方法，如判断当前渲染环境，以及路由跳转，跳到错误页面等，但比较神奇的一点是你除了在<code>asyncData</code>里，好像没法在别的地方找到这个<code>context</code>，我们可以在外部定义一个变量去指向它，以便在其他时候去使用（更坑的一点是，当使用服务端渲染时，前端是不会调用<code>asyncData</code>的，也就无法获得<code>context</code>）</p><h3 id="布局-layout"><a href="#布局-layout" class="headerlink" title="布局(layout)"></a>布局(layout)</h3><p>在外部包裹<code>page</code>的布局主体（参考其他服务端渲染的框架如ejs），一些公共的，例如声明全局组件之类的语句可以放在这层</p><h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><p>以下为使用<code>v1.0.0-rc6</code>版本遇到的一些问题，不确定新版本是否有修复，或者是否是个人理解有误</p><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>作为一个node后端开发，我至今无法在官方文档中找到一个简单明了的示例告诉我如何使用服务端渲染的功能，在官方的诸如<code>express</code>、<code>koa</code>示例程序中，我能看到的只有类似<code>app.use(nuxt.render)</code>的这种写法，这意味着我们并不能像传统的服务端渲染框架（以ejs为例）那样，传递一个包含着所有服务端数据的对象（<code>res.local</code>）给<code>render</code>函数</p><p>据我的理解，<code>Nuxt.js</code>致力完成的是“通用”的vue框架，它想使这个框架无论是前端还是后端渲染，都使用同样的代码，也就是说它始终在<code>asyncData</code>函数中去获取数据，这使得我们原本的node后端连简单地传递一个内存变量都很难做到</p><p>这是非常坑的一点，当<code>nuxt.config.js</code>中的<code>mode</code>处于<code>universal</code>时（默认是这个），前后端都有可能调用<code>asyncData</code>函数，<code>Nuxt.js</code>的示例里充斥着<code>axios</code>模块的引用，只是因为它在浏览器和node都可以运行，换句话来说，万一我们在<code>asyncData</code>使用的模块并不支持浏览器/node环境，就会出现问题</p><p>因此我现在只将<code>Nuxt.js</code>视为一个前端spa应用脚手架（在<code>nuxt.config.js</code>中设置<code>mode=&#39;spa&#39;</code>），而不会去用于服务端渲染，也只有在设置<code>mode=&#39;spa&#39;</code>之后，我们才能使用<code>nuxt generate</code>来正确生成一个单页静态前端项目</p><h3 id="plugins和modules"><a href="#plugins和modules" class="headerlink" title="plugins和modules"></a>plugins和modules</h3><p>官方建议我们把会反复用到的模块写在plugins里，甚至还要指明哪些是仅限服务端用的，哪些是浏览器用的，但却没有具体示例指出具体用途，至今还是很难理解这个逻辑</p><p>最近的版本还出现了modules目录，看起来是用于放置服务端的模块，具体文档太少也无法理解</p><h3 id="前端动态路由"><a href="#前端动态路由" class="headerlink" title="前端动态路由"></a>前端动态路由</h3><p>我们应该这样理解：<em>所有页面的路由逻辑都交给前端</em>，如果后端找不到url对应的接口/文件（即匹配不到任何路由，需要返回404的时候），应该渲染首页，由前端来告诉用户该页面不存在（Nuxt.js内置了错误页面）</p><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><p>个人用它结合<code>ElementUI</code>开发了一个简单的报表显示页面，不得不说预置layout+page的方式使得开发方便不少，但<code>asyncData</code>的运行环境问题还是一直在困扰我，最终还是抛弃了与印象中有很大出入的“服务端渲染”，设置<code>mode=&#39;spa&#39;</code>来生成静态前端页面，将它视为一个高级脚手架来用还是很不错的</p><p>目前该项目还在频繁更新，尚未发布正式版1.0，文档更新滞后且稍显混乱，部分细节没有介绍，因此目前不建议用于正式项目</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/Nuxt-js%E8%AF%95%E7%94%A8%E5%B0%8F%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人使用Elastic+Kibana的一些经验</title>
      <link>https://ngtmuzi.github.io/%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8Elastic-Kibana%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C/</link>
      <guid>https://ngtmuzi.github.io/%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8Elastic-Kibana%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C/</guid>
      <pubDate>Mon, 17 Jul 2017 11:03:51 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在记录日志的时候引入了elk栈，但日志写入部分是自己写的，并没有使用&lt;code&gt;logstash&lt;/code&gt;，因此经验就不包括&lt;code&gt;logstash&lt;/code&gt;啦&lt;/p&gt;
&lt;h2 id=&quot;ElasticSearch部分&quot;&gt;&lt;a href=&quot;#ElasticSear
        
      
      </description>
      
      <content:encoded><![CDATA[<p>在记录日志的时候引入了elk栈，但日志写入部分是自己写的，并没有使用<code>logstash</code>，因此经验就不包括<code>logstash</code>啦</p><h2 id="ElasticSearch部分"><a href="#ElasticSearch部分" class="headerlink" title="ElasticSearch部分"></a>ElasticSearch部分</h2><h3 id="有一个管理后台"><a href="#有一个管理后台" class="headerlink" title="有一个管理后台"></a>有一个管理后台</h3><p>ElasticSearch（以下简称ES）本身不带GUI，官方插件集x-pack添加到kibana中的monitoring界面只能看索引/集群信息却不能做管理，在你想删除/关闭/合并分段等操作的时候就会感觉束手无策，用RESTful的工具（如Chrome的插件PostMan）来请求ES的接口固然是一种方法，但毕竟不是长久之策，除非你喜欢这么玩……</p><p>目前Github上最受欢迎的项目是<a href="https://github.com/mobz/elasticsearch-head">elasticsearch-head</a>，功能完善足以满足需求，不过在一些小细节不是很尽如人意……比如它是纯前端去访问ES接口的，会碰到跨域问题，官方提供的解决方法如下：</p><ul><li>去改ElasticSearch的配置允许跨域</li><li>开一个允许跨域的本地代理（项目自身有提供）</li><li>安装一个插件到ES上</li></ul><p>根据自己项目的实际情况也可以自己做一个后台实现一些简单的功能，类似这样</p><p><img src="/img/elk_desc_1.png" alt=""></p><h3 id="注意资源使用量"><a href="#注意资源使用量" class="headerlink" title="注意资源使用量"></a>注意资源使用量</h3><p>数据量大而资源不足的情况下要尤其注意这点，即使按照ES官方文档的推荐设置好配置，也给了32G大内存，ES还是会在某些深夜默默地GC超时然后内存溢出崩溃，以下是一些建议：</p><ul><li>最好使用3台及以上的机器组成集群来使用</li><li>负责接受写入请求的节点以及主节点最好不存数据，避免这个节点崩溃后上游调用方全都写不进数据</li><li>定时清理内部的索引，一般推荐的索引维度是按天分索引，因此可以做一些通配条件来对一定时间前的索引做删除/关闭/合并分段操作减少内存占用</li></ul><h3 id="注意文档字段的类型"><a href="#注意文档字段的类型" class="headerlink" title="注意文档字段的类型"></a>注意文档字段的类型</h3><p>向ES写入数据时，要注意JSON内各字段的类型，ES会“智能”地以字段第一次出现时的类型来动态建立Mapping（参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.2/dynamic-field-mapping.html">官方文档</a>），并且不能在之后改变。假设<code>a</code>字段第一次传的是字符串，而第二次传了数值，ES会返回一个Mapping不匹配的错误，另外如果你传的字符串第一次刚好符合日期的格式，那么这个字段就被认为是Date类型，下次传其他字符串的时候也会返回Mapping错误，这点要注意避免</p><h2 id="kibana部分"><a href="#kibana部分" class="headerlink" title="kibana部分"></a>kibana部分</h2><h3 id="lucene语法"><a href="#lucene语法" class="headerlink" title="lucene语法"></a>lucene语法</h3><p><a href="http://lucene.apache.org/core/6_6_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html">官方文档</a>，个人的使用经验是遇事不决用括号<code>()</code>，很多时候搜索结果不符合预期是因为没有括号导致解析器误解了搜索条件</p><h3 id="慎用通配符"><a href="#慎用通配符" class="headerlink" title="慎用通配符"></a>慎用通配符</h3><p>在搜索字符串两侧都加<code>*</code>可能会有严重的性能问题，这点要小心</p><h3 id="导出数据到Excel"><a href="#导出数据到Excel" class="headerlink" title="导出数据到Excel"></a>导出数据到Excel</h3><p>虽然kibana本身的图表功能已经非常强大了，但总是有些需求要你导出数据到excel等工具上做进一步的分析，注意在图表的左下角有箭头，展开之后就能看到导出数据的按钮了</p><p><img src="/img/elk_desc_2.png" alt=""></p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8Elastic-Kibana%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>实现一个简单的Promise队列</title>
      <link>https://ngtmuzi.github.io/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%E9%98%9F%E5%88%97/</link>
      <guid>https://ngtmuzi.github.io/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%E9%98%9F%E5%88%97/</guid>
      <pubDate>Wed, 21 Jun 2017 14:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;em&gt;原博客创建于 2016-9-18 22:34:48， 更新于 2017-6-21 22:00:00&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;来自一个
        
      
      </description>
      
      <content:encoded><![CDATA[<p><em>原博客创建于 2016-9-18 22:34:48， 更新于 2017-6-21 22:00:00</em></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。</p><p>很直观的改进方案就是用队列，系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是Promise写的，做流程控制好歹比callback简单多了</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p><code>Promise</code>本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。</p></li><li><p>队列本身要有节流功能，即可以控制同一时间内在运行的<code>Promise</code>数量，参考<code>bluebird</code>的<code>map</code>函数中的concurrency(并发)字段。</p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>比较核心的代码简化起来就这一段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span></span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">        .<span class="title function_">then</span>(fn)</span><br><span class="line">        .<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到我们是往<code>queue</code>队列里加入了一个函数，这个函数包裹了原函数<code>fn</code>，将它执行的同步或者异步的结果传给外层的<code>Promise</code>，这样对外表现就还是一个<code>Promise</code>，这个函数进入队列，等待轮到它执行的时机</p><p>之后就是在内部维护一个“正在运行的任务数量”，在<code>fn</code>运行前后做加减和判断，就可以控制并行数了</p><p>完整代码：<a href="https://github.com/ngtmuzi/np-queue">np-queue</a>  </p><p>运行起来的感觉类似这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> q = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = (<span class="params">value</span>) =&gt;  </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(value), <span class="number">1000</span>);  </span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">q.<span class="title function_">add</span>(<span class="function">()=&gt;</span><span class="title function_">delay</span>(<span class="number">1</span>)).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line">q.<span class="title function_">add</span>(<span class="function">()=&gt;</span><span class="title function_">delay</span>(<span class="number">2</span>)).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> delay_wrap = q.<span class="title function_">wrap</span>(delay);</span><br><span class="line"></span><br><span class="line"><span class="title function_">delay_wrap</span>(<span class="number">3</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="title function_">delay_wrap</span>(<span class="number">4</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure><p>默认并发数是1，因此代码会相隔1秒依次输出<code>1,2,3,4</code></p><p>放到业务代码上，原代码是<code>delay().then(...)</code>，现在改为<code>q.add(delay).then(...)</code>，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解</p><p>再配合<code>wrap()</code>方法我们能更透明地完成这件事，它直接给一个函数提供了一层包装：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapFn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> queue.<span class="title function_">add</span>(fn.<span class="title function_">bind</span>(thisArg, ...<span class="variable language_">arguments</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>原代码为<code>delay(a,b).then(...)</code>我们可以改为<code>delay_wrap(a,b).then(...)</code>，参数都不用改，透明地加了一层控制并发的逻辑，感觉很好。</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%E9%98%9F%E5%88%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>解决vue无法捕获input变动的问题</title>
      <link>https://ngtmuzi.github.io/%E8%A7%A3%E5%86%B3vue%E6%97%A0%E6%B3%95%E6%8D%95%E8%8E%B7input%E5%8F%98%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <guid>https://ngtmuzi.github.io/%E8%A7%A3%E5%86%B3vue%E6%97%A0%E6%B3%95%E6%8D%95%E8%8E%B7input%E5%8F%98%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Mon, 05 Jun 2017 05:35:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;自己的页面使用了vue和一款jquery的时间选择插件&lt;code&gt;datepicker&lt;/code&gt;，但选好时间后input框的变动并没有被
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>自己的页面使用了vue和一款jquery的时间选择插件<code>datepicker</code>，但选好时间后input框的变动并没有被vue捕获到</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://cn.vuejs.org/v2/guide/forms.html#基础用法">Vue表单控件绑定</a><br><a href="https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090">Vue源码</a><br><a href="http://api.jquery.com/val/#val-value">Jquery的val()方法说明</a><br><a href="http://www.cnblogs.com/Eden-cola/p/vue-v-model-with-input.html">从vue.js的源码分析…</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event">MDN: Event对象</a></p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>jquery的val方法文档写得很清楚：</p><blockquote><p>Setting values using this method (or using the native value property) does not cause the dispatch of the change event.</p></blockquote><p>在类似使用<code>jquery</code>的<code>val()</code>方法时或者原生dom方法改动input的值时，不会触发任何事件。</p><blockquote><p><a href="https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090">vue.js #L6090</a><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = lazy</span><br><span class="line">  ? <span class="string">&#x27;change&#x27;</span></span><br><span class="line">  : type === <span class="string">&#x27;range&#x27;</span></span><br><span class="line">    ? <span class="variable constant_">RANGE_TOKEN</span></span><br><span class="line">    : <span class="string">&#x27;input&#x27;</span>;</span><br></pre></td></tr></table></figure></p></blockquote><p>而vue是通过绑定事件（默认是<code>input</code>）来获知表单元素的变动的，因此这个问题就是因为插件直接用<code>.val()</code>设置了值，而vue无法获知。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们可以在改动值后手动触发<code>input</code>事件，注意这里我们需要使用DOM原生的<code>event</code>对象，而不能直接使用jquery的<code>.trigger()</code>方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.get(0)返回DOM原生对象</span></span><br><span class="line">$(<span class="string">&#x27;#input1&#x27;</span>).<span class="title function_">val</span>(<span class="string">&#x27;something&#x27;</span>).<span class="title function_">get</span>(<span class="number">0</span>).<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;input&#x27;</span>));</span><br></pre></td></tr></table></figure><br>在我这个具体问题中，监听插件的自定义事件就可以了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;.form_datetime&quot;</span>).<span class="title function_">datepicker</span>()</span><br><span class="line">  .<span class="title function_">on</span>(<span class="string">&#x27;changeDate&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">//触发DOM对象上的原生input事件</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;input&#x27;</span>))</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><br>注意如果input使用的修饰符带有<code>.lazy</code>则应该触发<code>change</code>事件</p><p>当然最好的办法还是避免使用其他库来改动表单，改为使用基于vue的插件之类的，省心省力</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/%E8%A7%A3%E5%86%B3vue%E6%97%A0%E6%B3%95%E6%8D%95%E8%8E%B7input%E5%8F%98%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Node监视文件以实现热更新</title>
      <link>https://ngtmuzi.github.io/Node%E7%9B%91%E8%A7%86%E6%96%87%E4%BB%B6%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0/</link>
      <guid>https://ngtmuzi.github.io/Node%E7%9B%91%E8%A7%86%E6%96%87%E4%BB%B6%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0/</guid>
      <pubDate>Tue, 16 May 2017 03:47:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在准备开始写的时候搜了一下相关的文章，看到了这篇fangshi的&lt;a href=&quot;http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/&quot;&gt;《Node.js Web应用代码热更新的另类思路》&lt;/a&gt;，写得很详细考虑得也很
        
      
      </description>
      
      <content:encoded><![CDATA[<p>在准备开始写的时候搜了一下相关的文章，看到了这篇fangshi的<a href="http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/">《Node.js Web应用代码热更新的另类思路》</a>，写得很详细考虑得也很全，我的思路也类似这样，不过在替换旧模块上有些不同，总结出来权当抛砖引玉。</p><p>为了方便说明，部分代码有省略细节，详细可以参见<a href="https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js">完整代码</a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我的最开始需求倒不是要实现热更新这样听起来很炫酷的功能，只是想动态更新配置文件（JSON或JS）的内容到内存，避免每次改小小的配置都要重启进程</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><ul><li>监视文件/目录改动</li><li>清空require.cache中的模块缓存并重新require</li><li>用新模块覆盖旧模块</li></ul><h2 id="监视文件-目录改动"><a href="#监视文件-目录改动" class="headerlink" title="监视文件/目录改动"></a>监视文件/目录改动</h2><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>首先使用<code>path.resolve</code>来定位文件，其实使用<code>require.resolve</code>可以根据<a href="https://nodejs.org/api/modules.html#modules_file_modules">node寻找模块的规则</a>更智能地定位到一个模块的入口文件（比如xxx/index.js）的，但更多情况下我们并不只是监视这个index.js而是想监视整个文件夹的改动（举个例子，index.js里require了同目录的xx.json并做了一系列计算最后把计算结果挂载<code>module.exports</code>上，这个时候单单监视index.js是没什么用的。）</p><h3 id="监视-防抖动"><a href="#监视-防抖动" class="headerlink" title="监视/防抖动"></a>监视/防抖动</h3><p>原本是简单地使用<code>fs.watch</code>来监视文件，但其在linux下是无法监视到子目录/文件的改动的（参见<a href="https://nodejs.org/api/fs.html#fs_caveats">node文档</a>），因此后来改用了被众多知名工具依赖的文件监视模块<a href="https://github.com/paulmillr/chokidar">chokidar</a>，并且出于实际情况增加了防抖动<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chokidar.<span class="title function_">watch</span>(filePath).<span class="title function_">on</span>(<span class="string">&#x27;all&#x27;</span>, lodash.<span class="title function_">debounce</span>(update, <span class="number">300</span>));</span><br></pre></td></tr></table></figure></p><h2 id="清空require-cache中的模块缓存并重新require"><a href="#清空require-cache中的模块缓存并重新require" class="headerlink" title="清空require.cache中的模块缓存并重新require"></a>清空require.cache中的模块缓存并重新require</h2><h3 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h3><p>考虑到监视的有可能是一个目录而非单个文件的情况，我们需要在清除时多考虑一下，把整个目录的引用都清除掉<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="built_in">require</span>.<span class="property">cache</span>).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">cachePath</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cachePath.<span class="title function_">startsWith</span>(filePath)) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">require</span>.<span class="property">cache</span>[cachePath];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="重新require"><a href="#重新require" class="headerlink" title="重新require"></a>重新require</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newModule = <span class="built_in">require</span>(filePath);</span><br></pre></td></tr></table></figure><p>这个时候可能会报一些找不到文件，代码语法错误之类的同步错误，这个属于预期范围内，我的处理逻辑如下：</p><ul><li>第一次require是同步的，这时的错误会同步抛出，一般来说就会结束进程，因为确实没找到文件</li><li>监视事件触发并重新require时产生的错误会丢给回调函数，并且保持原模块的内容不做更改（避免意外修改文件产生语法错误导致模块失效或进程退出）</li></ul><h2 id="用新模块覆盖旧模块"><a href="#用新模块覆盖旧模块" class="headerlink" title="用新模块覆盖旧模块"></a>用新模块覆盖旧模块</h2><p>如果我们在使用模块时能够遵守一个约定：<strong><code>module.exports</code>是Object，且其他模块永远从该模块所暴露的<code>module.exports</code>上取值</strong>，那么我们就不需要去做反射，闭包之类的处理，只要简单地使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target,newMoudle)</span><br></pre></td></tr></table></figure><br>就可以在保持该对象的引用不变的情况下增改属性，考虑到有删除属性的情况，我自己写了一段比较暴力的覆写的函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">override</span>(<span class="params">target, source</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(target).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!source.<span class="title function_">hasOwnProperty</span>(key)) <span class="keyword">delete</span> target[key];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(source).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">    target[key] = source[key];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>外部模块只要是遵守了上述约定，就可以完全透明地取得最新的属性内容，对于我主要的应用场景——动态读取配置文件来说，这个还是很容易遵守的</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>只有一个模块引用的话，直接调用即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> some = <span class="title function_">watchModule</span>(<span class="string">&#x27;./originModule&#x27;</span>);</span><br><span class="line"><span class="comment">//从module.exports上取得的一定是最新值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(some.<span class="property">a</span>);</span><br></pre></td></tr></table></figure><br>当有多处需要引用时，建议使用一个代理的模块来挂载，这样在其他模块就可以直接用普通的require了（注意不要对一个模块多次调用watchModule，这样会产生重复事件）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//originModule</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//代理模块</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">watchModule</span>(<span class="string">&#x27;./originModule&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他模块</span></span><br><span class="line"><span class="keyword">const</span> some = <span class="built_in">require</span>(<span class="string">&#x27;proxyModule&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从module.exports上取得的一定是最新值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(some.<span class="property">a</span>);</span><br></pre></td></tr></table></figure><br>具体到上面文章提到的express动态挂载路由，<code>app.use</code>需要的是一个函数，因此我们无能为力——原函数已经被<code>app.use</code>挂载到中间件链上了，这种情况还是考虑使用一层闭包吧</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思路都是类似的，只是我多加了一个约定，只要遵守这个约定我们就可以写出一个比较通用的监视模块，当然这也并不是万能的，比如module.exports必须是Object（其他类型可以用Object多包裹一层），很多极限条件也没考虑到（比如Proxy、不可变Object、原型链、不可枚举的属性等），但对于普通的业务代码和配置文件来说这应该是没有什么问题了  </p><p>另外提醒一点，允许动态更新代码是<strong>非常危险</strong>的，比如我提到的这种允许读js作为配置文件的情况，万一js里来句<code>process.exit</code>或者其他恶意代码就挂了，可以根据实际需要来考虑加上限制</p><p><a href="https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js">完整代码</a>，欢迎讨论指正。</p><h2 id="补充：旧模块资源的释放"><a href="#补充：旧模块资源的释放" class="headerlink" title="补充：旧模块资源的释放"></a>补充：旧模块资源的释放</h2><p>阅读了上面的文章后才发现确实没考虑到这里，并且由于配置文件并不是频繁改动，在正式环境下也没出现过问题，但测试过后确实存在旧模块没有释放的情况（考虑还是不周啊），我们可以参考上面文章中fangshi给出的代码来清除引用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = <span class="built_in">require</span>.<span class="property">cache</span>[modulePath];</span><br><span class="line"><span class="comment">// remove reference in module.parent</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">parent</span>) &#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">parent</span>.<span class="property">children</span>.<span class="title function_">splice</span>(<span class="variable language_">module</span>.<span class="property">parent</span>.<span class="property">children</span>.<span class="title function_">indexOf</span>(<span class="variable language_">module</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/Node%E7%9B%91%E8%A7%86%E6%96%87%E4%BB%B6%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用socket.io在页面上输出实时日志</title>
      <link>https://ngtmuzi.github.io/%E4%BD%BF%E7%94%A8socket-io%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E8%BE%93%E5%87%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97/</link>
      <guid>https://ngtmuzi.github.io/%E4%BD%BF%E7%94%A8socket-io%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E8%BE%93%E5%87%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Wed, 19 Apr 2017 12:02:57 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;想在管理页面上看到日志文件/进程的实时输出日志，这对于某些不能直接ssh登录服务器，又没有良好的日志工具，或者单纯只是想检查运行输出的场景会
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>想在管理页面上看到日志文件/进程的实时输出日志，这对于某些不能直接ssh登录服务器，又没有良好的日志工具，或者单纯只是想检查运行输出的场景会比较有用</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="来"><a href="#来" class="headerlink" title="来"></a>来</h4><p>使用<code>tail -f</code>来得到实时的文件流或者用<code>pm2 logs</code>获取pm2进程的输出流，考虑为每个流加上一个<code>订阅id</code>，这样就可以实现多端同时订阅了</p><h4 id="去"><a href="#去" class="headerlink" title="去"></a>去</h4><p>在web页面上说到实时，自然就想到用<code>websocket</code>啦，逻辑并不复杂，客户端传来一个<code>订阅id</code>，就把它与id对应的流的<code>data</code>事件挂钩起来，这样便能将数据传递过去</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>本文主要是给出一些实践的思路，所以不会有<code>socket.io</code>工作原理的说明</p><h4 id="产生流"><a href="#产生流" class="headerlink" title="产生流"></a>产生流</h4><p>使用<code>child_process.exec</code>运行子进程，该函数所返回的<code>stdout</code>属性就是一个可读流：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">exec</span>;</span><br><span class="line"><span class="comment">//存储所有stream的集合</span></span><br><span class="line"><span class="keyword">const</span> streams = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用tail -f读文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">file</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> <span class="variable">id</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFile</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">watchProcess</span>(<span class="string">`tail -f <span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的命令行，比如pm2 logs 0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">cmd</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> <span class="variable">id</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchProcess</span>(<span class="params">cmd</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">watchStream</span>(<span class="title function_">exec</span>(cmd).<span class="property">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对流做一些额外处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">stream</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> <span class="variable">id</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchStream</span>(<span class="params">stream</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id     = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  streams[id]  = stream;</span><br><span class="line">  stream.<span class="property">_buff</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//处理流的data事件，使其按行(\n结尾)来触发自定义的line事件</span></span><br><span class="line">  stream.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    stream.<span class="property">_buff</span> += data;</span><br><span class="line">    <span class="keyword">let</span> lines    = stream.<span class="property">_buff</span>.<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    stream.<span class="property">_buff</span> = lines.<span class="title function_">pop</span>();</span><br><span class="line">    lines.<span class="title function_">forEach</span>(<span class="function"><span class="params">line</span> =&gt;</span> stream.<span class="title function_">emit</span>(<span class="string">&#x27;line&#x27;</span>, line));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将流与socket-io订阅绑定"><a href="#将流与socket-io订阅绑定" class="headerlink" title="将流与socket.io订阅绑定"></a>将流与socket.io订阅绑定</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="title class_">SocketIO</span>(httpServer);</span><br><span class="line"></span><br><span class="line">io.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span> (<span class="params">socket</span>) &#123;</span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;sub&#x27;</span>, <span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!streams[id]) <span class="keyword">return</span> socket.<span class="title function_">emit</span>(<span class="string">&#x27;line&#x27;</span>, <span class="string">`该订阅id不存在: <span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//管道函数，收到流的line事件则将控制台的ansi格式内容转成html格式然后触发客户端的line事件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">pipe</span> = line =&gt; socket.<span class="title function_">emit</span>(<span class="string">&#x27;line&#x27;</span>, <span class="title function_">ansiHTML</span>(line));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅流的line事件</span></span><br><span class="line">    streams[id].<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, pipe);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="前端订阅id"><a href="#前端订阅id" class="headerlink" title="前端订阅id"></a>前端订阅id</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = io.<span class="title function_">connect</span>();</span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  app.<span class="property">rawLines</span>.<span class="title function_">push</span>(data);</span><br><span class="line">  <span class="keyword">if</span> (app.<span class="property">rawLines</span>.<span class="property">length</span> &gt; <span class="number">2000</span>) app.<span class="property">rawLines</span>.<span class="title function_">splice</span>(<span class="number">0</span>, app.<span class="property">rawLines</span>.<span class="property">length</span> - <span class="number">2000</span>); <span class="comment">//行数上限设为2000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;connect&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;connect succeed&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">emit</span>(<span class="string">&#x27;sub&#x27;</span>, <span class="string">&#x27;time&#x27;</span>);<span class="comment">//根据各种业务逻辑拿到一个订阅id并订阅</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>前端页面为了方便渲染非常多行的元素，使用的是vue，代码就不贴了，最终效果如下</p><p><img src="/img/webshell_1.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个东西功能接近于webshell了，最起码输出是可以显示了，再加个输入的接口就可以远程执行命令了，这里要提醒下允许远程执行命令是 <strong>非常危险</strong> 的。</p><p>主要的是思路，代码本身并不难，<a href="https://github.com/ngtmuzi/webshell-demo">demo已上传github</a>，由于是demo，各种错误捕获和回收处理都不完善，这个还请自己研究了~</p><h3 id="2017-06-14补充"><a href="#2017-06-14补充" class="headerlink" title="2017-06-14补充"></a>2017-06-14补充</h3><p>监听逐行输出可以直接使用Node自带的<code>readline</code>模块，示例代码已更新</p>]]></content:encoded>
      
      <comments>https://ngtmuzi.github.io/%E4%BD%BF%E7%94%A8socket-io%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E8%BE%93%E5%87%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
